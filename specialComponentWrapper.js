import {cabmap} from "/home/kdog3682/2024-javascript/csx/assets.js"
import {gridCalculation} from "/home/kdog3682/2024-javascript/csx/handlers.js"
import * as shapelangApps from "/home/kdog3682/2024-javascript/shapelang/apps.js"
// 03-13-2024 - add the ability to effect the children
// the return item can be a style object or a node object.
// if the object has a style field, that it is a node object





export {
    callableComponentWrapper,
    presets,
    specialComponentWrapper,
    specials,
}
/* deno-fmt-ignore */ import { pause, exit, assertObjectValue,assertValue, fooga, getExtraIndent, shellUnescape, assertEqual, asyncToggle, touched, chosen, lastOf, firstOf, isBlockEnter, group3, loremIpsum, exportString, deepToggle, maybeNewlineIndent, onAndOff, flattenModule, isModule, isNativeHtmlTag, partitionByValues, strcall, getLongest2, must, mconfig, unreachable, notify, storager, joiner, removeVeryStartingComments, ireplace, removeCommentsInPlace, editf, getLineTokens, IndexedStore, abstractError, bool, xassert, getSetLines, inMiddle, replaceLast, ensureExtension, multipleReplacer, getGradeLevel, constructEdit, getYear, Modulus, wrapClassMethods, proseReplacer, parseComments, parseFunctionDictComments, todo, dictAssertion, boundModularIncrement, construct, reduceToString2, pageTurner, assignCumulative, defaultMergeStrategy, dictSetter3, toArguments, reTemplate, parseFrontmatter, typeAssertion, defineGetter, assignAllowed, simpleRecursiveWalk, simpleArgument, exprTemplater, stringifyIfNotPrimitive, panic, stringerf, wrapFunction, regexTemplater, iso8601, strftime, walkChildEntries, getFiletype, matchf, isUrl, looksLikeFunction, toArgument2, notNull, CumulativeStorage2, simpleAssign, findAndMatch, infuseObjectArray, regexGetter, splitArg, isJavascriptComment, runTest, everyOther, splitByRange, get_regex, getImports, isJavascriptFile, isValidDateString, WriteObject, equalityf, group2, splitOnce2, dedent4, isLowerCase, looksLikeRegExpString, isRegExpString, getDependencies, camelSplit, toggle3, countf, isLiteralObject, bindMethodsAndState2, call, mget3, looks_like_object_function, create_functions_from_master, toStringArgumentPretty, codeChunks, smart_map, run_tests, hasStartingCallable, mapTemplate, aliaser, fixSelector, htmlTags, removePythonComments, simpleStringBreaker, colonConfig, operations, error, redColon, so2, group, parseSingleLineJson, Items, findDependencies, tryf, find4, localeString, cssComment, colonConfigf, trimArray, parseCallable, bringToLifeTextFix, localBringToLife, getCaller4, getErrorStack, forEach, getBindings, getExports, matchstr, filter4, allEqual, count, isNativeFunction, repeat, eat, getIndentAndText, StopWatch, stringDictSetter, getFunctionInfo, runRef, toLines, hasCallable, getProseWords, tally, paramify, codeSplit, debugConfig, logConfig, blueColon, toStringArgument3, stringCallable, simpleBinding, dashSplit4, appendBelow, appendAbove, removeLineComments, prependIfNecessary, smartDedent4, blueSandwich, walk4, findLineIndex, parseAB, applyTransform, kebabCase, getExcerpt, sortObject, buildFunction, maybeSort, parseFunction, isTypable, frontMatter, dictEntry, insertAfterIndex, State, bindMethods, cpop, tagRE, toggle2, createFunction2, assignIncrementedIndex, ufa, assignArray, regexFromComment, createParsersFromObject, imatch, globalConsoleDebug, bindMethodsAndState, isQuestion, oxfordComma, isUpperCase, getFunctionIdentifier, filter3, match, getMatch, alternatef, reCombine, assertion2, deepEqual, hasDollar, so, deepAssign, Tally, getFunctionNames, throwError, notEqual, tryString, prettyPrintCodeSnippet, prettyPrintErrorStack, iter, quotify, transformerf, assign, defineBinding, jspy, linebreak, stringCall2, reduce3, getClassParameters, assignOnTop2, isIdentifier, ndy, dashSplit3, runFunctionFromRef, equalf, alphabet, stateGetterFromSchema, mreplace, require, topLineComment, isChinese, replacef, ignoref, codeLibrary, splitLines, addArgumentQuotes, getBindings2, addCaret, mget2, getStartingConfig, incrementalEat, strlen, hr, setOnce, unescapeHtml, oxford, breakerf, runTests, map3, dateSplit, transformDict, walk3, toRegExp, tryAgainf, assertNotNull, getArgumentObject, isArgumentObject, typef, requireArg, keyAndValue, assignf, stateGetter3, objectFromArguments2, assignDefaults, transformValue, assign3, assignFresh3, evaluate3, scopedEvaluator, objectFromArguments, enforce, sub, filterObject, extractStartingJsonLikeConfig, unbrackify, newlineIndent2, deleteLine, both, normalizeIndent, getComment, secondComment, isStringRegExp, dashSplit2, clock, warning, errorStringify, alert, labelCase, bottomComment, stringCompose, getAnyIdentifier, chalkf, getNumbers, partitions, has, addUnit, toCallable, unquote, filter2, warn2, join2, caller2, assignOnce, longShort, shortLong, argPop, caller, assignOnTop, toggle, defineWindow, unescapeNewlines, escapeQuotes, unescapeQuotes, escapeNewlines, setAliases, announceCaller, removeStartingComments, smartBind, assignExisting, isObjectWithKey, eatStart, modularIncrementItem, getRegex, runFunction, isObjectLikeArray, itemGetter2, getAllKeys, prefixSlice, hasQuotes, assertion, diff, toggleState, initState, dunder, objectGetter, superTransform, popFilter, testRunner, assert2, insertAtDollar, popEmptyLine, getOptions, mergeSpecs, sortByKeys, map2, strictMessengerAssert, smartSplit, chalk4, typeLog, getFunctionName, Clock, search3, MyError, fuzzyMatch3, debugDisplay, getCaller3, messengerAssert, camelSlice, setPrototype, assignAliases, display, modifyNumber, toDict, setPush, modularIncrementIndex, longstamp, popIndex, toggleOnOff, locWrap, walk2, typeMatch, prettyStringify, getIdentifiers, CustomError, argMatch, brackify2, smartestDedent, modularIncrementNumber, AbstractMethodError, allUnique, Trie, boundarySplit, numberBoundarySplit, nodeLog, getFirst, defineProperty, supermix, partial, timeLog, timestamp, raise, getIdentifier, conditionalPrefix, conditionalSuffix, QueryList, fuzzyMatch2, buildDict, getTextAndCommand, sprawlFactory, getParameters2, pushf, intersection, union, blue, green, sandwich, getLastSpaces, smartDedent3, red, sort, debounce, checkValue, getCodeChunks, logf, boundary, myError, conditional, isStringFunction, toSpaces, objectf, searchAll, difference, singleQuote, itemGetter, slice2, mergeObjects, once, dashSplit, nchalk, coerceToObject, ArrayState, exporter2, indent2, iterator, removeAllComments, countParams, cumulativeSchemaAssign, argKwargSplit, argParse, removeInlineComments, getFrontMatter, hasHtmlSuffix, lazyArray, isThisFunction, escapeHTML, getKwargs2, search2, toStringArgument, createFuzzyMatch, edit2, splice, zip, merge2, argArgsKwargs, fill2, chalk, vueWrap, splitArray, splitArray2, warn, makeRunner2, searchf2, smartDedent2, dedent2, toArray2, stateGetter2, sortByIndex, IndexedCache, argo, curry2, doUntil2, evaluate2, findall2, findIndex2, findItem2, getCaller2, getErrorStack2, isJson, indexGetter2, insert2, pop2, parseError2, remove2, reduce2, testf2, type2, unshift2, waterfall2, xsplit2, Cache, cumulativeAssign, replaceBefore, topComment, isAsyncFunction, mapSort, getFileURI, getQuotes, isClassObject, isInitialized, getFallback, bindingRE, addObjectOrObjectProperty, forDoubles, isCss, log, iterate, backAndForth, round, iteratorWrapper, toJSON, isFromMap, toString, empty, conditionalString, getConfigArg, hasKey, errorWrap, successWrap, check, toPoints, bind, mixinAliases, isPercentage, isBasicType, reducerStrategy, gather, entries, stateGetter, methodCase, vueCase, push2, smarterIndent, lineSplit, Store, isSingleLetter, prepareText, isSymbol, getShortest, slice, KeyError, deepCopy, argsKwargs, isError, isColor, list, objectEditor, matchall, makeFastRunner, announce, hasLetter, filter, reduce, stringCall, capitalizeName, stop, proseCase, lineDitto, mixinSetters, modularIncrement, distinct, definedSort, groupBy, reWrap2, fuzzyMatch, isPlural, Element, parseError, isPrimitiveArray, callableArgsKwargs, waterfall, defineVariable, info, flat2D, splitThePage, handleError, dedent, TypeAssertion, createFunction, pluralize, remove, Group, PageStorage, Storage, UniqueStorage, Watcher, arrayToDict, addProperty, addQuotes, argWrapFactory, assert, abrev, abf, addExtension, assignFresh, antif, atFirst, atSecond, backspace, bindObject, breaker, blockQuote, brackify, bringToLife, comment, countCaptureGroups, capitalizeTitle, classMixin, callableRE, camelToTitle, curry, createVariable, changeExtension, curryStart, curryEnd, capitalize, copy, camelCase, compose, char2n, camelToDash, deepMerge, datestamp, doublef, dictSetter, dictSetter2, dsearch, doUntil, dashCase, doubleQuote, dict, dictGetter, depluralize, dreplace, dictf, endsWithWord, exporter, edit, exists, evaluate, extend, find, flatMap, fill, fixUrl, functionGetter, findall, fixPath, flat, fparse, findIndex, firstLine, ftest, getKwargs, getFirstName, getBindingName, getParameters, getLastWord, getCodeWords, getCodeWords2, getIndent, getExtension, getLast, getLongest, getChunks, getCaller, getStackTrace, getConstructorName, getFirstWord, getWords, getSpaces, hasComma, hasSpaces, hasHtml, hasBracket, hasNewline, hasCaptureGroup, hasEquals, hasValue, hasCamelCase, hasNumber, hackReplace, insert, indexGetter, incrementf, isCallable, isQuote, isEven, isOdd, isLast, isHTML, isNode, interweave, inferLang, isString, isArray, isObject, isDefined, isFunction, isPrimitive, isNumber, isSet, isNestedArray, indent, isNull, isWord, isBoolean, isRegExp, identity, isObjectLiteral, isJsonParsable, isCapitalized, isNewLine, isObjectArray, isStringArray, isClassFunction, joinSpaces, join, keyArrayToObject, lowerCase, linebreakRE, len, lineGetter, lineCount, lastLine, logConsole, makeRunner, mixin, modularf, matchGetter, merge, mget, map, mergeOnTop, mergeToObject, mapFilter, noop, nestPush, no, newlineIndent, n2char, objectWalk, overlap, objectToString, opposite, pipe, parseTopAttrs, pascalCase, partition, parens, push, pop, parseJSON, rigidSort, removeQuotes, rep, removeComments, range, removeExtension, rescape, reverse, reWrap, reduceToString, repeatUntil, swapKey, sayhi, swap, splitMapJoin, splitCamel, smallify, search, stringify, shared, smartDedent, stringBreaker, sleep, split, snakeCase, stringArgument, sorted, splitOnce, searchf, secondLine, titleCase, textOrJson, toNumber, toArgument, toNestedArray, test, type, tail, transformObject, trim, testf, toArray, templater, totalOverlap, upperCase, unique, uncapitalize, unzip, wrap, walk, wrapf, xsplit, yes, zip2} from "/home/kdog3682/2023/utils.js"

const containerStyleRef = {
    box({ size }) {
        const base = xsplit(size)
        const [width, height] = base.map((x) => x + "pt")
        return {
            attrs: {
                text: `${base.join(" x ")}`,
            },
            style: {
                width,
                height,
                border: "2px solid black",
            },
        }
    },
    flex({ size, gap, left }) {
        return {
            display: "flex",
            "column-gap": "5pt",
        }
    },

    columns({ size, gap, left, colgap }) {
        return
        const gridTemplateColumns =
            `repeat(${size}, minmax(${left}px, 1fr))`
        return {
            display: "grid",
            gap: `${gap}px`,
            columnGap: colgap ? `${colgap}` : null,
            "grid-template-columns": gridTemplateColumns,
        }
    },
}
function specialComponentWrapper(node) {
    return customComponentWrapper(node)
    const { component, attrs } = node.state
    if (!component) {
        return
    }

    if (component == "container") {
        const type = attrs.type
        if (containerStyleRef.hasOwnProperty(type)) {
            specialInfuser(node, type, attrs, container)
        }
    } else if (containerStyleRef.hasOwnProperty(component)) {
        specialInfuser(node, component, attrs)
    }
}
function specialInfuser(node, key, attrs, className) {
    const fn = containerStyleRef[key]
    const payload = fn(attrs || {})
    if (!payload) {
        return
    }
    node.state.component = null
    node.state.tag = "div"
    node.state.class = className || key

    if (payload.style) {
        node.assign(payload)
    } else {
        node.assign("style", payload)
    }
}

function callableComponentWrapper(node, externalChildren) {
    const { name, args, kwargs, members } = node.state
    const ref = customComponentRef[name]
    const { self, children } = ref
    if (self) {
        if (self.handler) {
            const value = self.handler(args, kwargs)
            handle(node, value)
        }
    }
    if (children && exists(externalChildren)) {
        if (children.handler) {
            const runner = (child, i, a) => {
                const value = children.handler(child, i, a)
                childHandler(child, value)
            }
            externalChildren.forEach(runner)
        }
    }
}

const customComponentRef2 = {
    // this is where everything happens
    grid: {
        main(node, {template, gap, cgap, rgap, css, columns}) {
            if (columns) {
                const style = fromColumns({columns, gap})
                return node.assign({style})
            }
            const {self, children} = gridCalculation(template)

            runChildren(node, (child, i) => {
                child.assign({style: children[i]})
            })
            if (gap) self['grid-gap'] = addUnit(gap, 'px')
            if (rgap) self['grid-row-gap'] = addUnit(rgap, 'px')
            if (cgap) self['grid-column-gap'] = addUnit(cgap, 'px')
            node.assign({style: self})
            // console.log(node.children.map((x) => x.state))
        },
    },

    component: {
        self: {
            handler() {
                return null
                return {
                    tag: 'component'
                }
            }
        }
    },
    icon: {
        self: {
            handler(attrs) {
                return {
                    tag: 'span',
                    class: 'icon',
                }
            }
        }
    },
    container: {
        self: {
            handler(attrs) {
                const base = {
                    attrs: {
                        name: attrs.name,
                    },
                    style: {
                        "margin-bottom": "20px",
                    },
                }
                if (attrs.type) {
                    const ref = customComponentRef2[attrs.type]
                    if (ref) {
                        deepAssign(base, ref(attrs))
                    }
                } else {
                    
                }
                return base
            },
        },
    },

    columns: {
        self: {
            handler({ gap, left, size, align }) {
                const p = {
                    display: "flex",
                }
                if (align) {
                    p["align-items"] = "center"
                }
                if (gap) {
                    p["gap"] = gap + "pt"
                }
                return p
            },
        },
    },

    flex: {
        self: {
            handler({ spacing, gap, align, dir, layout }) {
                if (spacing) {
                    gap = spacing
                }
                const p = layout ? cab(layout) : {
                    display: "flex",
                }
                if (align) {
                    p["align-items"] = "center"
                }
                if (dir) {
                    p["flex-direction"] = 'column'
                }

                if (gap) {
                    p["gap"] = gap + "pt"
                }
                return {
                    style: p,
                }
            },
        },
        children: {
            handler(child, i, children) {
            },
        },
    },
}
const customComponentRef = {
    linebreak: {
        self: {
            handler(args, kwargs) {
                return {
                    tag: "div",
                    style: {
                        width: "100%",
                        "border-bottom": args[0] +
                            "px solid blue",
                        "padding-bottom": "5px",
                        "margin-bottom": "5px",
                    },
                }
            },
        },
    },

    divider: {
        self: {
            handler(args, kwargs) {
            },
        },
    },
    lorem: {
        self: {
            handler(args, kwargs) {
                if (!kwargs.fill) {
                    kwargs.fill = "blue"
                }
                const [width, height] = args.length == 2
                    ? args
                    : [args[0], args[0]]
                const value = kwargs?.label
                    ? capitalize(kwargs.label[0])
                    : `${width} x ${height}`
                return {
                    classes: ["lorem"],
                    style: {
                        background: kwargs?.fill,
                        "font-weight": kwargs?.label
                            ? "bold"
                            : null,
                        "font-size": kwargs?.label
                            ? null
                            : "10pt",
                        width: width + "pt",
                        height: height + "pt",
                        border: "1px solid black",
                    },
                    // text: value,
                }
            },
        },
        children: {
            handler(child, i, children) {
                panic("lorem is not allowed to have children")
                return {
                    asdf: 1,
                }
            },
        },
    },
}
function customComponentWrapper(node) {
    const { component, attrs } = node.state
    if (!component || /^[a-zA-Z]\w*-\w/.test(component)) {
        return
    }
    function getter() {
        try {
            return component == "container"
                ? [attrs?.type || "container", component]
                : [component, component]
        } catch (e) {
            console.log(component)
            throw e
        }
    }
    const [key, className] = getter()

    const ref = customComponentRef2[key]
    assertObjectValue(ref, 'customComponentRef2', key, 'the corresponding node.computedText is: ',  node.computedText || 'null')

    const { self, children, main } = ref
    if (main) {
        node.assign({attrs: {name: node.state.component}})
        node.state.component = null
        main(node, attrs || {})
        return 
    }
    if (children) {
        let arg
        if (children.getArg) {
             arg = children.getArg(attrs || {})
        }
        node.children.filter(isElement).forEach((x , i) => children.handler(x, i, arg))
    }
    if (self) {
        if (self.handler) {
            const value = self.handler(attrs || {})
            if (value === null) {
                return 
            }
            handle(node, value)
        }
        // node.state.tag = 'div'
        node.assign({ tag: "div", classes: [className] })
        node.state.component = null
    }
}

function handle(node, value) {
    if (!value) {
        return
    } else if (value.style) {
        node.assign(value)
    } else {
        node.assign("style", value)
    }
}
function childHandler(node, value) {
    if (!value) {
        return
    } else if (value.style) {
        deepAssign(node, value)
    } else {
        console.log("aa")
        console.log("doesnt work because it is a string")
        throw node
        deepAssign(node, "style", value)
    }
}

const specials = {
    spacer(node) {
        const m = addUnit(node.state.args[0], 'pt')
        return `<div style="margin-bottom: ${m}"></div>`
    },
    v(node) {
        node.nextSibling.assign(
            "style",
            "margin-top",
            node.state.args[0] + "pt",
        )
    },
}

const presets = {
    shapelang: shapelangApps,
}
function isElement(child) {
	
            if (child.state.tag || child.state.component || child.state.text) {
                return true
            }

}
function runChildren(node, fn) {
        node.children.filter(isElement).forEach(fn)
}
function cab(s) {
    return dict(must(cabmap, s))
}
function fromColumns({columns, gap}) {
    const gridTemplateColumns = `repeat(${columns}, 1fr)`
    return {
        display: 'grid',
        'grid-template-columns': gridTemplateColumns,
            gap: gap ? addUnit(gap, 'px') : null
    }
}
