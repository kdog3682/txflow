import * as variables from "/home/kdog3682/2023/variables.js"
import * as csx from "/home/kdog3682/2024-javascript/csx/main.js"
import {
    toContentString,
    normalizeContents,
    normalizeIndents
} from "/home/kdog3682/2024-javascript/txflow/helpers.js"
/* prettier-ignore */ import {fooga, mconfig, unreachable, notify, storager, joiner, removeVeryStartingComments, ireplace, removeCommentsInPlace, editf, getLineTokens, IndexedStore, abstractError, bool, xassert, getSetLines, inMiddle, replaceLast, ensureExtension, multipleReplacer, getGradeLevel, constructEdit, getYear, Modulus, wrapClassMethods, proseReplacer, parseComments, parseFunctionDictComments, todo, dictAssertion, boundModularIncrement, construct, reduceToString2, pageTurner, assignCumulative, defaultMergeStrategy, dictSetter3, toArguments, reTemplate, parseFrontmatter, typeAssertion, defineGetter, assignAllowed, simpleRecursiveWalk, simpleArgument, exprTemplater, stringifyIfNotPrimitive, panic, stringerf, wrapFunction, regexTemplater, iso8601, strftime, walkChildEntries, getFiletype, matchf, isUrl, looksLikeFunction, toArgument2, notNull, CumulativeStorage2, simpleAssign, findAndMatch, infuseObjectArray, regexGetter, splitArg, isJavascriptComment, runTest, everyOther, splitByRange, get_regex, getImports, isJavascriptFile, isValidDateString, WriteObject, equalityf, group2, splitOnce2, dedent4, isLowerCase, looksLikeRegExpString, isRegExpString, getDependencies, camelSplit, toggle3, countf, isLiteralObject, bindMethodsAndState2, call, mget3, looks_like_object_function, create_functions_from_master, toStringArgumentPretty, codeChunks, smart_map, run_tests, hasStartingCallable, mapTemplate, aliaser, fixSelector, htmlTags, removePythonComments, simpleStringBreaker, colonConfig, operations, error, redColon, so2, group, parseSingleLineJson, Items, findDependencies, tryf, find4, localeString, cssComment, colonConfigf, trimArray, parseCallable, bringToLifeTextFix, localBringToLife, getCaller4, getErrorStack, forEach, getBindings, getExports, matchstr, filter4, allEqual, count, isNativeFunction, repeat, eat, getIndentAndText, StopWatch, stringDictSetter, getFunctionInfo, runRef, toLines, hasCallable, getProseWords, tally, paramify, codeSplit, debugConfig, logConfig, blueColon, toStringArgument3, stringCallable, simpleBinding, dashSplit4, appendBelow, appendAbove, removeLineComments, prependIfNecessary, smartDedent4, blueSandwich, walk4, findLineIndex, parseAB, applyTransform, kebabCase, getExcerpt, sortObject, buildFunction, maybeSort, parseFunction, isTypable, frontMatter, dictEntry, insertAfterIndex, State, bindMethods, cpop, tagRE, toggle2, createFunction2, assignIncrementedIndex, ufa, assignArray, regexFromComment, createParsersFromObject, imatch, globalConsoleDebug, bindMethodsAndState, isQuestion, oxfordComma, isUpperCase, getFunctionIdentifier, filter3, match, getMatch, alternatef, reCombine, assertion2, deepEqual, hasDollar, so, deepAssign, Tally, getFunctionNames, notEqual, tryString, prettyPrintCodeSnippet, prettyPrintErrorStack, iter, quotify, transformerf, assign, defineBinding, jspy, linebreak, stringCall2, reduce3, getClassParameters, assignOnTop2, isIdentifier, ndy, dashSplit3, runFunctionFromRef, equalf, alphabet, stateGetterFromSchema, mreplace, require, topLineComment, isChinese, replacef, ignoref, codeLibrary, splitLines, addArgumentQuotes, getBindings2, addCaret, mget2, getStartingConfig, incrementalEat, strlen, hr, setOnce, unescapeHtml, oxford, breakerf, runTests, map3, dateSplit, transformDict, walk3, toRegExp, tryAgainf, assertNotNull, getArgumentObject, isArgumentObject, typef, requireArg, keyAndValue, assignf, stateGetter3, objectFromArguments2, assignDefaults, transformValue, assign3, assignFresh3, evaluate3, scopedEvaluator, objectFromArguments, enforce, sub, filterObject, extractStartingJsonLikeConfig, unbrackify, newlineIndent2, deleteLine, both, normalizeIndent, getComment, secondComment, isStringRegExp, dashSplit2, clock, warning, errorStringify, alert, labelCase, bottomComment, stringCompose, getAnyIdentifier, chalkf, getNumbers, partitions, has, addUnit, toCallable, unquote, filter2, warn2, join2, caller2, assignOnce, longShort, shortLong, argPop, caller, assignOnTop, toggle, defineWindow, unescapeNewlines, escapeQuotes, unescapeQuotes, escapeNewlines, setAliases, announceCaller, removeStartingComments, smartBind, assignExisting, isObjectWithKey, eatStart, modularIncrementItem, getRegex, runFunction, isObjectLikeArray, itemGetter2, getAllKeys, prefixSlice, hasQuotes, assertion, diff, toggleState, initState, dunder, objectGetter, superTransform, popFilter, testRunner, assert2, insertAtDollar, popEmptyLine, getOptions, mergeSpecs, sortByKeys, map2, strictMessengerAssert, smartSplit, chalk4, typeLog, getFunctionName, Clock, search3, MyError, fuzzyMatch3, debugDisplay, getCaller3, messengerAssert, camelSlice, setPrototype, assignAliases, display, modifyNumber, toDict, setPush, modularIncrementIndex, longstamp, popIndex, toggleOnOff, locWrap, walk2, typeMatch, prettyStringify, getIdentifiers, CustomError, argMatch, brackify2, smartestDedent, modularIncrementNumber, AbstractMethodError, allUnique, Trie, boundarySplit, numberBoundarySplit, nodeLog, getFirst, defineProperty, supermix, partial, timeLog, timestamp, raise, getIdentifier, conditionalPrefix, conditionalSuffix, QueryList, fuzzyMatch2, buildDict, getTextAndCommand, sprawlFactory, getParameters2, pushf, intersection, union, blue, green, sandwich, getLastSpaces, smartDedent3, red, sort, debounce, checkValue, getCodeChunks, logf, boundary, myError, conditional, isStringFunction, toSpaces, objectf, searchAll, difference, singleQuote, itemGetter, slice2, mergeObjects, once, dashSplit, nchalk, coerceToObject, ArrayState, exporter2, indent2, iterator, removeAllComments, countParams, cumulativeSchemaAssign, argKwargSplit, argParse, removeInlineComments, getFrontMatter, hasHtmlSuffix, lazyArray, isThisFunction, escapeHTML, getKwargs2, search2, toStringArgument, createFuzzyMatch, edit2, splice, zip, merge2, argArgsKwargs, fill2, chalk, vueWrap, splitArray, splitArray2, warn, makeRunner2, searchf2, smartDedent2, dedent2, toArray2, stateGetter2, sortByIndex, IndexedCache, argo, curry2, doUntil2, evaluate2, findall2, findIndex2, findItem2, getCaller2, getErrorStack2, isJson, indexGetter2, insert2, pop2, parseError2, remove2, reduce2, testf2, type2, unshift2, waterfall2, xsplit2, Cache, cumulativeAssign, replaceBefore, topComment, isAsyncFunction, mapSort, getFileURI, getQuotes, isClassObject, isInitialized, getFallback, bindingRE, addObjectOrObjectProperty, forDoubles, isCss, log, iterate, backAndForth, round, iteratorWrapper, toJSON, isFromMap, toString, empty, conditionalString, getConfigArg, hasKey, errorWrap, successWrap, check, toPoints, bind, mixinAliases, isPercentage, isBasicType, reducerStrategy, gather, entries, stateGetter, methodCase, vueCase, push2, smarterIndent, lineSplit, Store, isSingleLetter, prepareText, isSymbol, getShortest, slice, KeyError, deepCopy, argsKwargs, isError, isColor, list, objectEditor, matchall, makeFastRunner, announce, hasLetter, filter, reduce, stringCall, capitalizeName, stop, proseCase, lineDitto, mixinSetters, modularIncrement, distinct, definedSort, groupBy, reWrap2, fuzzyMatch, isPlural, Element, parseError, isPrimitiveArray, callableArgsKwargs, waterfall, defineVariable, info, flat2D, splitThePage, handleError, dedent, TypeAssertion, createFunction, pluralize, remove, Group, PageStorage, Storage, UniqueStorage, Watcher, arrayToDict, addProperty, addQuotes, argWrapFactory, assert, abrev, abf, addExtension, assignFresh, antif, atFirst, atSecond, backspace, bindObject, breaker, blockQuote, brackify, bringToLife, comment, countCaptureGroups, capitalizeTitle, classMixin, callableRE, camelToTitle, curry, createVariable, changeExtension, curryStart, curryEnd, capitalize, copy, camelCase, compose, char2n, camelToDash, deepMerge, datestamp, doublef, dictSetter, dictSetter2, dsearch, doUntil, dashCase, doubleQuote, dict, dictGetter, depluralize, dreplace, dictf, endsWithWord, exporter, edit, exists, evaluate, extend, find, flatMap, fill, fixUrl, functionGetter, findall, fixPath, flat, fparse, findIndex, firstLine, ftest, getKwargs, getFirstName, getBindingName, getParameters, getLastWord, getCodeWords, getCodeWords2, getIndent, getExtension, getLast, getLongest, getChunks, getCaller, getStackTrace, getConstructorName, getFirstWord, getWords, getSpaces, hasComma, hasSpaces, hasHtml, hasBracket, hasNewline, hasCaptureGroup, hasEquals, hasValue, hasCamelCase, hasNumber, hackReplace, insert, indexGetter, incrementf, isCallable, isQuote, isEven, isOdd, isLast, isHTML, isNode, interweave, inferLang, isString, isArray, isObject, isDefined, isFunction, isPrimitive, isNumber, isSet, isNestedArray, indent, isNull, isWord, isBoolean, isRegExp, identity, isObjectLiteral, isJsonParsable, isCapitalized, isNewLine, isObjectArray, isStringArray, isClassFunction, joinSpaces, join, keyArrayToObject, lowerCase, linebreakRE, len, lineGetter, lineCount, lastLine, logConsole, makeRunner, mixin, modularf, matchGetter, merge, mget, map, mergeOnTop, mergeToObject, mapFilter, noop, nestPush, no, newlineIndent, n2char, objectWalk, overlap, objectToString, opposite, pipe, parseTopAttrs, pascalCase, partition, parens, push, pop, parseJSON, rigidSort, removeQuotes, rep, removeComments, range, removeExtension, rescape, reverse, reWrap, reduceToString, repeatUntil, swapKey, sayhi, swap, splitMapJoin, splitCamel, smallify, search, stringify, shared, smartDedent, stringBreaker, sleep, split, snakeCase, stringArgument, sorted, splitOnce, searchf, secondLine, titleCase, textOrJson, toNumber, toArgument, toNestedArray, test, type, tail, transformObject, trim, testf, toArray, templater, totalOverlap, upperCase, unique, uncapitalize, unzip, wrap, walk, wrapf, xsplit, yes, zip2} from "/home/kdog3682/2023/utils.js"
export { vueBlocks }
import { lazyObjectParser } from "../../2023/lazyObjectParser2.js"
import { xmlString } from "../../2023/xmlString2.js"
import { htmlParser } from "../../2023/htmlParser2.js"

const switchBlock = {
    priority: "A",
    type: "switch",
    match: /^switch +(.+)/,
    automaticallyMatch: true,
    visit(node) {
        let switchExpr = node.switch
        if (!isWord(switchExpr)) {
            switchExpr = this.state.namer("switch")
            const body =
                "return " + node.switch.replace(/\((\w+)\)/g, "(this.$1)")
            const switcherFn = buildFunction({ body }, Function)
            this.state.addFunction("computed", switchExpr, switcherFn)
        }
        node.children
            .filter((x) => x.type == "case")
            .forEach((child, i) => {
                child.switchExpr = switchExpr
                child.switchCount = i
            })
        const values = node.children.map(this.visit).filter(exists)
        node.assign({ tag: "div", class: "switch-container" })
        return this.state.wrap(node, values)
    }
}
// the priorities should have started lower
// and as you need them to go higher ...
// when one side doesnt give the same amount
const caseBlock = {
    priority: "A",
    type: "case",
    match: /^case +(.+)|^(default)$/,
    automaticallyMatch: true,
    visit(node) {
        assert(node.children.length == 1)
        const m = node.case
        const key =
            m == "default"
                ? "v-else"
                : node.switchCount == 0
                ? "v-if"
                : "v-else-if"
        const value = m == "default" ? "" : `${node.switchExpr} == '${m}'`
        node.firstChild.assign("attrs", key, value)
        return this.visit(node.firstChild)
    }
}
const inlineDirective = {
    priority: "A",
    type: "directive",
    match: /^(v(?:-\w+)+(?:[.:]\w+)*) * = *(\S.+)/,
    run() {
        this.eat()
        const [a, b] = this.matches
        this.token.assign("state", "attrs", a, b)
        this.token.assign("directive", b)
        this.token.assign("implied", [b])
    },
    visit(node) {
        node.parent.assign(node.state)
        this.state.implicits.push(node.directive)
    }
}

// never ask yijie about work
// never ask him to see your point of view
// my parents ... were just doing their best
// and they did alright ...
// but one pair of adults just isnt enough.
// you need more support than 25% to 50% of your parents.
// we were just kids
// i can provide warm support

const attrBlock = {
    priority: "A",
    type: "attribute",
    match: /^([:@]#)?([a-zA-Z]{2,}[$\w-_.]*)(?: *= *(.+))$|^([:@])([a-zA-Z]{2,}[$\w-_.]*)$/,
    run() {
        this.eat()
        let [a, b, c, d, e] = this.matches
        // console.log({a, b, c, d, e})
        if (d) {
            a = d
            b = e
        }
        let label = a == ":" ? "props" : a == "@" ? "events" : "attrs"
        const isSlot = a == "#"
        if (isSlot) {
            label = "#" + label
        }
        const key = variables.vmap2[b] || b
        const value = c || b
        if (key == "v-for") {
            return handleFor(this, c)
        }
        if (key == "v-if" || key == "v-else-if" || isSlot || key == "v-model") {
            this.token.assign("implied", [value])
        }
        this.token.assign("state", label, key, value)
    },
    visit(node) {
        node.parent.assign(node.state)
        return null
    }
}

const functionBlock = {
    priority: "A",
    type: "function",
    match: /^(?:async +)?(?:function +)?(\w+).*?{ *$/,
    run() {
        this.getBlock({ includeEndpoint: true })
    },
    visit(node) {
        this.state.handleFunction(node)
    }
}

const commentBlock = {
    match: /^\/{2,} *(debug)?/,
    type: "comment",
    automaticallyEat: true,
    // ignorable: true,
    priority: "A",
    run() {
        const mode = this.matches[0]
        if (mode) {
            switch (mode) {
                case "debug":
                    this.options.debug = true
                // throw this.options
            }
        }
        this.token.touched(false)
    }
}

const lopBlock = {
    priority: 1000,
    desc: "lops and labels",
    type: "lop",
    match: /^([a-zA-Z][\w-]+):(?: +\w+.*)?$/,
    run() {
        this.getBlock({ includeEndpoint: false })
    },
    visit(node) {
        const lopRef = {
            // class:
            // booga: dinosaur
            // fooga: foogasaur
            directive(componentState, parent, b) {
                let s = "v-"
                s += b.name

                parent.assign("attrs", s, b.value)
                this.state.implicits.push(b.value)
                // you can have additional stuff ...
            },
            class(componentState, parent, b) {
                function fn() {
                    const filter = ([k, v]) => {
                        return this[v] ? k : null
                    }
                    const classes = mapFilter(Object.entries(b), filter)
                    return classes
                }

                const name = "computedClass"
                const count = componentState.nameTally.add(name)
                const fnName = name + count
                parent.assign("props", "class", fnName)
                componentState.assign("computed", fnName, fn)
            }
        }
        const lop = lazyObjectParser(node.contents)
        const entries = Object.entries(lop)
        assert(entries.length == 1, "entries.length will always be 1")
        const [a, b] = entries[0]

        if (node.startIndent == 0) {
            if (variables.vueComponentOptionKeys.includes(a)) {
                this.state.assign(lop)
            } else {
                deepAssign(this.state.options, lop)
            }
        } else {
            console.log(lop)
            if (a in lopRef) {
                lopRef[a](this.state, node.parent, b)
            } else if (someDepth(b, /^this\.\w+$/)) {
                deepAssign(node.parent, "computedLopStyle", a, b)
            } else {
                // console.log(lop)
                node.parent.assign(csx.toStyleObject(csx.converter(lop)))
            }
        }
    }
}

/* @bookmark 1709344576 defaultblock */
const defaultBlock = {
    priority: 1000,
    type: "default",
    check: yes,
    run() {
        const line = this.eat()
        const aliases = {
            container: "v-container"
        }
        const parsed = htmlParser(line.text)
        // console.log({parsed})
        if (this.options.debug) {
            console.log(getCaller(), parsed)
        }
        if (parsed.implied) this.token.set("implied", parsed.implied, true)
        if (parsed.ignored) this.token.set("ignored", parsed.ignored, true)
        if (parsed.component in aliases) {
            parsed.component = aliases[parsed.component]
        }
        this.token.set("state", parsed, true)
    },
    visit(node) {
        if (node.state.component) {
            this.state.assign("componentKeys", [node.state.component])
        }
        const children = this.visitChildren(node)
        return this.state.wrap(node, children)
    }
}

const rootVisitBlock = {
        type: "Root",
        visit(node) {
            let template = node.children
                .map(this.visit)
                .filter(exists)
                .join("\n")
            return this.state.build(node, template)
        }
}
const vueBlocks = [
    caseBlock,
    switchBlock,
    functionBlock,
    inlineDirective,
    attrBlock,
    commentBlock,
    lopBlock,
    defaultBlock,
    rootVisitBlock,
]

function passChildrenDown(node, father) {
    const intermediate = node.create(father)
    intermediate.append(node.children)
    node.children = [intermediate]
}
function handleFor(state, c) {
    const r = /^\(?(\w+)(?:, *(\w+)\)?) +in +(.+)/
    const [key, index, expr] = match(c, r)
    const text = index ? `(${key}, ${index}) in ${expr}` : `${key} in ${expr}`
    const ignored = flat(key, index)
    const implied = match(expr, /(\w+)(?:$|[.])/)
    state.token.assign("ignored", ignored)
    state.token.assign("implied", [implied])
    state.token.assign("state", "attrs", "v-for", text)
}

function someDepth(o, r) {
    if (isString(o)) {
        if (r.test(o)) {
            return true
        }
        return false
    }
    function runner(o) {
        for (const [k, v] of Object.entries(o)) {
            if (isString(v)) {
                if (r.test(v)) {
                    return true
                }
            } else if (isObject(v)) {
                let status = runner(v)
                if (status === true) {
                    return true
                }
            }
        }
    }
    return runner(o)
}
/* @bookmark 1709344576 defaultblock */
